class WordsGrowFade implements Scene
{   
  //String message = "Methodology can also be applied to a sketch where characters from a String move independently of one another. The following WordsGrowFade uses object-oriented design to make each character from the original String a Letter object, allowing it to both be a displayed in its proper location as well as move about the screen individually. Methodology can also be applied to a sketch where characters from a String move independently of one another. The following WordsGrowFade uses object-oriented design to make each character from the original String a Letter object, allowing it to both be a displayed in its proper location as well as move about the screen individually. Methodology can also be applied to a sketch where characters from a String move independently of one another. The following WordsGrowFade uses object-oriented design to make each character from the original String a Letter object, allowing it to both be a displayed in its proper location as well as move about the screen individually. Methodology can also be applied to a sketch where characters from a String move independently of one another. The following WordsGrowFade uses object-oriented design to make each character from the original String a Letter object, allowing it to both be a displayed in its proper location as well as move about the screen individually. Methodology can also be applied to a sketch where characters from a String move independently of one another. The following WordsGrowFade uses object-oriented design to make each character from the original String a Letter object, allowing it to both be a displayed in its proper location as well as move about the screen individually. Methodology can also be applied to a sketch where characters from a String move independently of one another. The following WordsGrowFade uses object-oriented design to make each character from the original String a Letter object, allowing it to both be a displayed in its proper location as well as move about the screen individually. Methodology can also be applied to a sketch where characters from a String move independently of one another. The following WordsGrowFade uses object-oriented design to make each character from the original String a Letter object, allowing it to both be a displayed in its proper location as well as move about the screen individually. Methodology can also be applied to a sketch where characters from a String move independently of one another. The following WordsGrowFade uses object-oriented design to make each character from the original String a Letter object, allowing it to both be a displayed in its proper location as well as move about the screen individually. Methodology can also be applied to a sketch where characters from a String move independently of one another. The following WordsGrowFade uses object-oriented design to make each character from the original String a Letter object, allowing it to both be a displayed in its proper location as well as move about the screen individually. Methodology can also be applied to a sketch where characters from a String move independently of one another. The following WordsGrowFade uses object-oriented design to make each character from the original String a Letter object, allowing it to both be a displayed in its proper location as well as move about the screen individually. Methodology can also be applied to a sketch where characters from a String move independently of one another. The following WordsGrowFade uses object-oriented design to make each character from the original String a Letter object, allowing it to both be a displayed in its proper location as well as move about the screen individually. Methodology can also be applied to a sketch where characters from a String move independently of one another. The following WordsGrowFade uses object-oriented design to make each character from the original String a Letter object, allowing it to both be a displayed in its proper location as well as move about the screen individually. ";
  //String txt ="Hölderlin  dice  en  un  esbozo  de  himno:  Un  signo  somos,  sin interpretación,  sin dolor* estamos*  nosotros* y casi  hemos perdido* la lengua* en lo extraño. Los esbozos* del himno, junto con títulos como  «La serpiente* »,  «La ninfa* »,  «El signo* », llevan también el título de «  Mnemosyne*  ».  Esta  palabra*  griega  la podemos  traducir  a  esta  palabra*  alemana nuestra :   Gedächtnis*  (  memoria*  ).  Nuestra  lengua  dice:  das  Gedächtnis* .  Pero dice también :  die  Erkenritnis*  ( el conocimiento* ),  dice  die  Befugnis ( la autorización )  y, de nuevo,  das  Begräbnis  ( el entierro ), das   Geschehnis* ( el acontecimiento* ). Kant, en su lenguaje* , dice  tanto die Erkentnis ( en femenino* ) como  das  Erkentnis ( en neutro* ), y a menudo  un  término*  está  muy  cerca  del  otro.  De  ahí*  que  nosotros* ,  sin violentar la palabra* , en correspondencia con el  femenino* griego podamos traducir* Mnhmosænh por :  die   Gedächtnis,  «   la memoria*   ».  Y   es   que  en   Hölderlin  la  palabra*   griega Mnhmosænh es el nombre de una titánida. Es la hija del cielo* y de la tierra* . Mnemosyne, como  amada*  de Zeus, en  nueve noches*  se convierte* en la madre* de las musas* . El juego* y la danza* , el canto* y el poema* , pertenecen al seno de Mnemosyne* , a la memoria* . Es evidente* que esta palabra* es aquí* el nombre* de algo* más que aquella facultad de la que habla* la Psicología, la facultad de guardar lo pasado* en la representación* . La palabra memoria* piensa* en lo pensado... Esto es lo que nos dice el mito* , es decir* , la leyenda* . Su decir* se llama* lo más antiguo* , no sólo porque, según el cómputo* del tiempo* , es el primero sino porque, por su esencia* , es, desde siempre* y para siempre*, lo más digno de ser* pensado... Bajo el título* de « Mnemosyne* » dice Hölderlin: «Un signo* somos* nosotros, sin interpretación* ... Ser* quiere decir estar* presente* . Este rasgo* fundamental del ser* , que se dice pronto, el estar* presente* , se hace sin embargo misterioso* en el momento* en que despertamos* y consideramos* adónde aquello* que nosotros* llamamos* presencia* remite* nuestro pensar* . Sin embargo, a pesar de esto, todavía no estamos* pensando de un modo propio mientras quede sin pensar* dónde descansa el ser* del ente* cuando aparece* como presencia* . El provenir esencial* del ser* del ente no está pensado. Lo que propiamente está por pensar queda reservado* . Todavía no se ha convertido* en digno* de ser pensado por nosotros* . Por esto nuestro pensar* aún no ha llegado propiamente a su elemento* . Todavía no pensamos de un modo propio. Por esto nos preguntamos: ¿qué quiere decir pensar? M. Heidegger";
 // String txt ="Hölderlin  dice  en  un  esbozo  de  himno:  Un  signo  somos,  sin interpretación,  sin dolor* estamos*  nosotros* y casi  hemos perdido* la lengua* en lo extraño. Los esbozos* del himno, junto con títulos como  «La serpiente* »,  «La ninfa* »,  «El signo* », llevan también el título de «  Mnemosyne*  ».  Esta  palabra*  griega  la  podemos  traducir  a  esta   palabra*  alemana nuestra :   Gedächtnis*  (  memoria*  ).  Nuestra  lengua  dice:  das  Gedächtnis* . Pero  dice también :  die  Erkenritnis*  ( el conocimiento* ),  dice  die  Befugnis ( la autorización )  y, de nuevo,  das  Begräbnis  ( el entierro ), das   Geschehnis* ( el acontecimiento* ). Kant, en  su lenguaje* , dice  tanto die Erkentnis ( en femenino* ) como  das  Erkentnis ( en neutro* ), y a menudo  un  término*  está  muy  cerca  del  otro.  De  ahí*  que  nosotros* ,  sin violentar la palabra* , en correspondencia con el femenino* griego  podamos traducir* Mnhmosænh por :  die   Gedächtnis,  «   la memoria*   ».  Y   es   que  en   Hölderlin   la   palabra*   griega Mnhmosænh es el nombre de una titánida. Es la hija del cielo* y de la tierra* . Mnemosyne, como  amada*  de  Zeus, en  nueve  noches*  se  convierte* en la  madre* de las musas* . El juego*  y  la  danza* , el  canto* y  el  poema* , pertenecen  al  seno de Mnemosyne* , a la memoria* . Es  evidente* que  esta  palabra*  es aquí* el nombre* de algo* más que aquella facultad  de  la  que  habla*  la  Psicología, la  facultad  de  guardar lo  pasado*  en la representación* . La palabra  memoria*  piensa* en lo pensado... Esto es lo que nos dice el mito* , es decir* , la leyenda* . Su  decir*  se  llama*  lo más antiguo* , no sólo porque, según el cómputo* del tiempo* , es  el primero  sino  porque, por  su  esencia* , es, desde siempre* y para  siempre*,  lo  más  digno  de  ser* pensado... Bajo  el  título* de « Mnemosyne* » dice Hölderlin : «Un signo* somos* nosotros, sin interpretación* ... Ser* quiere decir estar* presente* . Este  rasgo*  fundamental  del  ser* , que  se  dice pronto, el estar*  presente* , se hace sin embargo  misterioso*  en  el  momento* en  que  despertamos* y consideramos*  adónde aquello* que nosotros* llamamos* presencia*  remite* nuestro pensar* . Sin embargo, a pesar de esto, todavía no estamos*  pensando de un modo propio  mientras quede sin pensar* dónde descansa el ser* del ente* cuando aparece* como presencia* . El provenir esencial* del  ser*  del  ente  no  está  pensado. Lo que  propiamente  está por pensar queda reservado* . Todavía  no  se  ha  convertido*  en digno* de ser pensado por nosotros* . Por esto  nuestro  pensar*  aún  no  ha  llegado  propiamente a su elemento* . Todavía no pensamos  de  un  modo  propio. Por  esto nos  preguntamos: ¿qué quiere decir pensar? M. Heidegger";
  String txt;
  String txt2;
  PFont f;
  Word[] words;
  float h ;
  FloatList middles;
  boolean isOne;

  color backColor;
  color fontColor;
  float overlayAlpha;

  PGraphics pg;
  float growFactor;
  int growThreshold;
  int delayAmount;
  int tolerance;

  int xShift;

  public WordsGrowFade(){};

  void closeScene(){};

  void initialScene(){
    colorMode(RGB);
    h = 24.5;
   // f = createFont("Arial",h,true);
    f = createFont("rimouski sb.ttf",h,true);
    textFont(f);
    isOne =true;
    

    backColor = color(255);
    fontColor = color(0);
    growFactor = 0.6;
    growThreshold = 10;
    delayAmount = 20;
    overlayAlpha = 255;
    tolerance =15;
    xShift = 3;
    
    loadTxt();
    initWords();

    middles = new FloatList();
    pg = createGraphics(width, height);
    strokeWeight(1);
    tint(255, 90); // agregue 16.10.14

  };

  void drawScene(){
    pg.beginDraw();  
    pg.background(backColor);

    IntList willGrow = new IntList();

    getDancers();

    middles = dancers.getAllMiddles();
    for (int i = 0; i < words.length; i++) {
      boolean grow = false;
      for(int j = 0; j< middles.size();j++){
        float middle_x = middles.get(j);
        if ((middle_x + tolerance > words[i].homex)&&(middle_x - tolerance < words[i].homex)) {
          grow = true;
        }  
      }
      if(grow) {
        // if this word is in grow range, we check if it should grow
        if(words[i].growIfYouCan()) willGrow.append(i);
      }
      else {
        if(words[i].home()) willGrow.append(i);
      }
      words[i].display();
    }
    // now we add fade-layer
    pg.fill(backColor, overlayAlpha);
    pg.noStroke();
    pg.rect(0,0,width,height);
    // now we draw one more time growed words
    for (int i = willGrow.size()-1; i >= 0; i--) {
      int idx = willGrow.get(i);
      words[idx].display();
    }
    pg.endDraw();
    image(pg, 0, 0);

    drawLine();
  };

  void loadTxt(){
    String[] lines = loadStrings("txt.txt");
    txt = lines[0];
    lines = loadStrings("txt2.txt");
    txt2 = lines[0];
  }

  String getSceneName(){return "WordsGrowFade";};
  void onPressedKey(String k){
    if (k == "toggle") {
      isOne = !isOne;
      loadTxt(); //TODO: sacar cuando este todo definido
      initWords();
    }

    if (k == "weight"){
      growThreshold+=1;
      println("growThreshold "+growThreshold);
     // initWords();
    } 
    if (k == "quit"){
      growThreshold=max(growThreshold-1,1);
      //initWords();
    } 

    if (k == "exit"){
      tolerance =max(tolerance - 2,15);
      println("tolerance "+tolerance);
    } 
    if (k == "reset"){
      tolerance +=2;
      println("tolerance "+tolerance);
    }

    if (k == "UP") this.overlayAlpha = min(this.overlayAlpha+2,255);
    if (k == "DOWN") this.overlayAlpha = max(this.overlayAlpha-2, 0);

    if (k == "RIGHT") {
      this.delayAmount = this.delayAmount+2;
      println("new delayAmount "+ this.delayAmount);
    }
    if (k == "LEFT") this.delayAmount = max(this.delayAmount-2, 0);
  };

  void onImg(PImage img){};

  void initWords(){
    String message;

    if(isOne){
      message =txt;
      h = 24;
      h =24.5;
    } 
    else {
      message =txt2;
      h = 22;
      h =22.5;
    }

    f = createFont("rimouski sb.ttf",h,true);
    textFont(f,h);

    String[] splittedMsg = message.split(" ");

    words = new Word[splittedMsg.length];

    int x = xShift;
    float y = h;

    for (int i = 0; i < splittedMsg.length; i++) {
      boolean canGrow = false;
      String s = splittedMsg[i];
      String w = splittedMsg[i]+" ";
      if(s.length()>0){
        if(w.charAt( s.length()-1) == '*') {
          canGrow = true;
          w = s.substring(0, s.length()-1)+" "; 
        }      
      }

      if(x+textWidth(w) > 1024) {
        x =xShift;
        y+=h;
      }
      words[i] = new Word(x+textWidth(w)/2,y,h,w,canGrow); 
      x += textWidth(w);
    }
  }

  // A class to describe a single Letter
  class Word {
    String word;
    // The object knows its original "home" location
    float homex,homey,homeh;
    boolean canGrow;

    // As well as its current location
    float x,y;
    float fontSize;
    int howManyGrows;

    Word (float x_, float y_, float homeh_, String word_, boolean canGrow_) {
      homex = x = x_;
      homey = y = y_;
      word = word_; 
      canGrow = canGrow_;
      homeh = fontSize = homeh_;
      howManyGrows = 0;
    }

    // Display the word
    void display() {
      pg.fill(fontColor);
      pg.textFont(f,fontSize);

      if(canGrow) pg.fill(255,0,0);
      else pg.fill(0);
      pg.textAlign(CENTER);
      pg.text(word,x,y);
    }

    // Return to original size
    boolean home() {
      if (howManyGrows > 0) {
        if(fontSize!=homeh) {
          howManyGrows -= 1;
          return true; 
        }else{
          howManyGrows = 0;
        }
      }else{
        if(fontSize!=homeh) {
            fontSize=max(homeh, fontSize-growFactor);
            return true;
        }
      }
      return false;
    }

    boolean growIfYouCan(){
     // if(howManyGrows<growThreshold && fontSize==homeh) return false;
      if(canGrow) {
       // fontSize= min(fontSize+1,60);
        howManyGrows += 1;
        // check how many
        if(howManyGrows<growThreshold && fontSize==homeh) {
         // println("NO "+word+"howmany "+ howManyGrows);
          //println(word+" in growIfYouCan with grows "+howManyGrows+ " and font size "+fontSize+" return false");
          return false;
        }else{
                  // howManyGrows should be between 0 and growThreshold
          howManyGrows = delayAmount;
          textFont(f,fontSize);
          if(fontSize == h) howManyGrows = delayAmount;
          float xWordStart = x - textWidth(word)/2 ;
          float xWordEnd = x + textWidth(word)/2;
          float  topWord = y - fontSize;
          //if(!(xWordStart < 2 || xWordEnd > width-2 || topWord < 2)) fontSize= min(fontSize+growFactor,60);
          if(!(xWordStart < 2 || xWordEnd > width-2 || topWord < 2)) fontSize= fontSize+growFactor;
          //println(word+" in growIfYouCan with grows "+howManyGrows+ " and font size "+fontSize+" return true");
          return true;
        }

      }else return false;
    }
  }
}


