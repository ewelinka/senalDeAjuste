class WordsGrowFade implements Scene
{   
  //String message = "Methodology can also be applied to a sketch where characters from a String move independently of one another. The following WordsGrowFade uses object-oriented design to make each character from the original String a Letter object, allowing it to both be a displayed in its proper location as well as move about the screen individually. Methodology can also be applied to a sketch where characters from a String move independently of one another. The following WordsGrowFade uses object-oriented design to make each character from the original String a Letter object, allowing it to both be a displayed in its proper location as well as move about the screen individually. Methodology can also be applied to a sketch where characters from a String move independently of one another. The following WordsGrowFade uses object-oriented design to make each character from the original String a Letter object, allowing it to both be a displayed in its proper location as well as move about the screen individually. Methodology can also be applied to a sketch where characters from a String move independently of one another. The following WordsGrowFade uses object-oriented design to make each character from the original String a Letter object, allowing it to both be a displayed in its proper location as well as move about the screen individually. Methodology can also be applied to a sketch where characters from a String move independently of one another. The following WordsGrowFade uses object-oriented design to make each character from the original String a Letter object, allowing it to both be a displayed in its proper location as well as move about the screen individually. Methodology can also be applied to a sketch where characters from a String move independently of one another. The following WordsGrowFade uses object-oriented design to make each character from the original String a Letter object, allowing it to both be a displayed in its proper location as well as move about the screen individually. Methodology can also be applied to a sketch where characters from a String move independently of one another. The following WordsGrowFade uses object-oriented design to make each character from the original String a Letter object, allowing it to both be a displayed in its proper location as well as move about the screen individually. Methodology can also be applied to a sketch where characters from a String move independently of one another. The following WordsGrowFade uses object-oriented design to make each character from the original String a Letter object, allowing it to both be a displayed in its proper location as well as move about the screen individually. Methodology can also be applied to a sketch where characters from a String move independently of one another. The following WordsGrowFade uses object-oriented design to make each character from the original String a Letter object, allowing it to both be a displayed in its proper location as well as move about the screen individually. Methodology can also be applied to a sketch where characters from a String move independently of one another. The following WordsGrowFade uses object-oriented design to make each character from the original String a Letter object, allowing it to both be a displayed in its proper location as well as move about the screen individually. Methodology can also be applied to a sketch where characters from a String move independently of one another. The following WordsGrowFade uses object-oriented design to make each character from the original String a Letter object, allowing it to both be a displayed in its proper location as well as move about the screen individually. Methodology can also be applied to a sketch where characters from a String move independently of one another. The following WordsGrowFade uses object-oriented design to make each character from the original String a Letter object, allowing it to both be a displayed in its proper location as well as move about the screen individually. ";
  //String txt = "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa bbbbbbbbbbbbbbbbbbb* ccccccccccccccccc";
  String txt ="Hölderlin dice en un esbozo de himno: Un signo somos, sin interpretación, sin dolor* estamos* nosotros* y casi hemos perdido* la lengua* en lo extraño. Los esbozos* del himno, junto con títulos como «La serpiente* », «La ninfa* », «El signo* », llevan también el título de « Mnemosyne* ». Esta palabra* griega la podemos traducir a esta palabra* alemana nuestra: Gedächtnis* ( memoria* ). Nuestra lengua dice: das Gedächtnis* . Pero dice también: die Erkenritnis* (el conocimiento* ), dice die Befugnis (la autorización) y, de nuevo, das Begräbnis (el entierro), das Geschehnis* (el acontecimiento* ). Kant, en su lenguaje* , dice tanto die Erkentnis (en femenino* ) como das Erkentnis (en neutro* ), y a menudo un término* está muy cerca del otro. De ahí* que nosotros* , sin violentar la palabra* , en correspondencia con el femenino* griego podamos traducir* Mnhmosænh por: die Gedächtnis, «la memoria* ». Y es que en Hölderlin la palabra* griega Mnhmosænh es el nombre de una titánida. Es la hija del cielo* y de la tierra* . Mnemosyne, como amada* de Zeus, en nueve noches* se convierte* en la madre* de las musas* . El juego* y la danza* , el canto* y el poema* , pertenecen al seno de Mnemosyne* , a la memoria* . Es evidente* que esta palabra* es aquí* el nombre* de algo* más que aquella facultad de la que habla* la Psicología, la facultad de guardar lo pasado* en la representación* . La palabra memoria* piensa* en lo pensado... Esto es lo que nos dice el mito* , es decir* , la leyenda* . Su decir* se llama* lo más antiguo* , no sólo porque, según el cómputo* del tiempo* , es el primero sino porque, por su esencia* , es, desde siempre* y para siempre*, lo más digno de ser* pensado... Bajo el título* de « Mnemosyne* » dice Hölderlin: «Un signo* somos* nosotros, sin interpretación* ... Ser* quiere decir estar* presente* . Este rasgo* fundamental del ser* , que se dice pronto, el estar* presente* , se hace sin embargo misterioso* en el momento* en que despertamos* y consideramos* adónde aquello* que nosotros* llamamos* presencia* remite* nuestro pensar* . Sin embargo, a pesar de esto, todavía no estamos* pensando de un modo propio mientras quede sin pensar* dónde descansa el ser* del ente* cuando aparece* como presencia* . El provenir esencial* del ser* del ente no está pensado. Lo que propiamente está por pensar queda reservado* . Todavía no se ha convertido* en digno* de ser pensado por nosotros* . Por esto nuestro pensar* aún no ha llegado propiamente a su elemento* . Todavía no pensamos de un modo propio. Por esto nos preguntamos: ¿qué quiere decir pensar? M. Heidegger";
  String txt2 = "El   hombre  comunica   su   propia  esencia  espiritual  (en  la  medida  en  que  es  comunicable) nombrando* todas las otras cosas* . Pero ¿ conocemos* otras lenguas* que nombran las cosas* ? No se objete que no conocemos* otra lengua fuera de la del hombre: no es cierto* . En realidad* , no conocemos ninguna* lengua denominante* fuera de la del hombre* ; al identificar* lengua* denominante* con lengua en general, la teoría* lingüística* se priva de sus nociones* más profundas* . La esencia* lingüística* del hombre es por lo tanto nombrar* las cosas* . ¿Por qué las nombra? ¿Con quién se comunica* el hombre* ? -¿Es acaso este problema* en el caso del hombre* distinto que en otras comunicaciones (lenguas)? ¿Con quién* se comunica* la lámpara? ¿Y la montaña* ? ¿Y el zorro?- Pero aquí* la respuesta* dice* : con el hombre. Ello no es en absoluto* antropomorfismo* . La verdad* de esta respuesta* se revela* en el conocimiento* y quizás* también en el arte* … Es necesario establecer una diferencia* profunda* , una alternativa* frente a la cual se desenmascare inevitablemente la concepción* esencialmente falsa* de la lengua… Esta concepción* es la concepción burguesa* de la lengua* , cuya vacua* inconsistencia* resultará enseguida más clara. Tal teoría* dice que el medio de la comunicación es la palabra* , que su objeto* es la cosa* y que su destinatario es un hombre* . Mientras que la otra teoría* no* distingue* ningún medio* , ningún objeto* , ningún destinatario de la comunicación. Dice: en el nombre el ser* espiritual* del hombre se comunica* con Dios* … Toda naturaleza* , en cuanto se comunica* , se comunica en la lengua* , y por lo tanto en última* instancia en el hombre* . Por ello el hombre es el señor de la naturaleza* y puede* nombrar las* cosas* . Sólo a través de la esencia* lingüística* de las cosas llega el hombre desde sí* mismo* al conocimiento* de éstas: en el nombre. La creación* de Dios* se completa* cuando las cosas reciben su* nombre* del hombre, de quien en el nombre habla* sólo la lengua* … En la designación* del hombre como parlante* (que es, según la Biblia, el dador de nombres: \"toda denominación que el hombre pusiera a los seres* vivientes, tal fuese su nombre\") muchas lenguas encierran* en sí este conocimiento* metafísico. Pero el* nombre* no es sólo la última exclamación* , sino también la verdadera* alocución* de la lengua. Aparece* así en el nombre la ley* esencial* de la lengua, para la cual expresarse* y apostrofar toda otra* cosa* es un mismo movimiento* . La lengua –y en ella* un ser* espiritual* - se expresa* puramente sólo cuando* habla* en el nombre, es decir en la denominación universal* . Culmina así* en el nombre la totalidad* intensiva* de la lengua como del ser* espiritual* absolutamente comunicable* , y la totalidad* extensiva* de la lengua como de ser universalmente comunicante (denominante). La lengua es imperfecta* en su esencia* comunicante, en su universalidad, cuando el ser espiritual que ella habla no es lingüístico, es decir, comunicable* , en toda su estructura. Sólo el hombre tiene la lengua perfecta* en universalidad e intensidad.(...) W. Benjamin";

  PFont f;
  Word[] words;
  int h = 24;
  FloatList middles;
  boolean isOne;

  color backColor;
  color fontColor;
  float overlayAlpha;

  PGraphics pg;
  float growFactor;
  int growThreshold;
  int delayAmount;
  int tolerance;

  public WordsGrowFade(){};

  void closeScene(){};

  void initialScene(){
    colorMode(RGB);
   // f = createFont("Arial",h,true);
    f = createFont("rimouski sb.ttf",h,true);
    textFont(f);
    isOne =true;
    initWords();

    backColor = color(255);
    fontColor = color(0);
    growFactor = 0.6;
    growThreshold = 10;
    delayAmount = 20;
    overlayAlpha = 255;
    tolerance =15;

    middles = new FloatList();
    pg = createGraphics(width, height);
    strokeWeight(1);
    tint(255, 40); // agregue 16.10.14

  };

  void drawScene(){
    pg.beginDraw();  
    pg.background(backColor);

    IntList willGrow = new IntList();

    getDancers();

    middles = dancers.getAllMiddles();
    for (int i = 0; i < words.length; i++) {
      boolean grow = false;
      for(int j = 0; j< middles.size();j++){
        float middle_x = middles.get(j);
        if ((middle_x + tolerance > words[i].homex)&&(middle_x - tolerance < words[i].homex)) {
          grow = true;
        }  
      }
      if(grow) {
        // if this word is in grow range, we check if it should grow
        if(words[i].growIfYouCan()) willGrow.append(i);
      }
      else {
        if(words[i].home()) willGrow.append(i);
      }
      words[i].display();
    }
    // now we add fade-layer
    pg.fill(backColor, overlayAlpha);
    pg.noStroke();
    pg.rect(0,0,width,height);
    // now we draw one more time growed words
    for (int i = willGrow.size()-1; i >= 0; i--) {
      int idx = willGrow.get(i);
      words[idx].display();
    }
    pg.endDraw();
    image(pg, 0, 0);

    drawLine();
  };

  String getSceneName(){return "WordsGrowFade";};
  void onPressedKey(String k){
    if (k == "toggle") {
      isOne = !isOne;
      initWords();
    }

    if (k == "weight"){
      growThreshold+=1;
      println("growThreshold "+growThreshold);
     // initWords();
    } 
    if (k == "quit"){
      growThreshold=max(growThreshold-1,1);
      //initWords();
    } 

    if (k == "exit"){
      tolerance =max(tolerance - 2,15);
      println("tolerance "+tolerance);
    } 
    if (k == "reset"){
      tolerance +=2;
      println("tolerance "+tolerance);
    }

    if (k == "UP") this.overlayAlpha = min(this.overlayAlpha+2,255);
    if (k == "DOWN") this.overlayAlpha = max(this.overlayAlpha-2, 0);

    if (k == "RIGHT") {
      this.delayAmount = this.delayAmount+2;
      println("new delayAmount "+ this.delayAmount);
    }
    if (k == "LEFT") this.delayAmount = max(this.delayAmount-2, 0);
  };

  void onImg(PImage img){};

  void initWords(){
    String message;

    if(isOne){
      message =txt;
      h = 24;
    } 
    else {
      message =txt2;
      h = 22;
    }

    f = createFont("rimouski sb.ttf",h,true);
    textFont(f,h);

    String[] splittedMsg = message.split(" ");

    words = new Word[splittedMsg.length];

    int x = 16;
    int y = h;

    for (int i = 0; i < splittedMsg.length; i++) {
      boolean canGrow = false;
      String s = splittedMsg[i];
      String w = splittedMsg[i]+" ";
      if(s.length()>0){
        if(w.charAt( s.length()-1) == '*') {
          canGrow = true;
          w = s.substring(0, s.length()-1)+" "; 
        }      
      }

      if(x+textWidth(w) > 1024) {
        x =16;
        y+=h;
      }
      words[i] = new Word(x+textWidth(w)/2,y,h,w,canGrow); 
      x += textWidth(w);
    }
  }

  // A class to describe a single Letter
  class Word {
    String word;
    // The object knows its original "home" location
    float homex,homey,homeh;
    boolean canGrow;

    // As well as its current location
    float x,y;
    float fontSize;
    int howManyGrows;

    Word (float x_, float y_, float homeh_, String word_, boolean canGrow_) {
      homex = x = x_;
      homey = y = y_;
      word = word_; 
      canGrow = canGrow_;
      homeh = fontSize = homeh_;
      howManyGrows = 0;
    }

    // Display the word
    void display() {
      pg.fill(fontColor);
      pg.textFont(f,fontSize);

      // if(canGrow) pg.fill(255,0,0);
      // else pg.fill(0);
      pg.textAlign(CENTER);
      pg.text(word,x,y);
    }

    // Return to original size
    boolean home() {
      if (howManyGrows > 0) {
        if(fontSize!=homeh) {
          howManyGrows -= 1;
          return true; 
        }else{
          howManyGrows = 0;
        }
      }else{
        if(fontSize!=homeh) {
            fontSize=max(homeh, fontSize-growFactor);
            return true;
        }
      }
      return false;
    }

    boolean growIfYouCan(){
     // if(howManyGrows<growThreshold && fontSize==homeh) return false;
      if(canGrow) {
       // fontSize= min(fontSize+1,60);
        howManyGrows += 1;
        // check how many
        if(howManyGrows<growThreshold && fontSize==homeh) {
         // println("NO "+word+"howmany "+ howManyGrows);
          //println(word+" in growIfYouCan with grows "+howManyGrows+ " and font size "+fontSize+" return false");
          return false;
        }else{
                  // howManyGrows should be between 0 and growThreshold
          howManyGrows = delayAmount;
          textFont(f,fontSize);
          if(fontSize == h) howManyGrows = delayAmount;
          float xWordStart = x - textWidth(word)/2 ;
          float xWordEnd = x + textWidth(word)/2;
          float  topWord = y - fontSize;
          //if(!(xWordStart < 2 || xWordEnd > width-2 || topWord < 2)) fontSize= min(fontSize+growFactor,60);
          if(!(xWordStart < 2 || xWordEnd > width-2 || topWord < 2)) fontSize= fontSize+growFactor;
          //println(word+" in growIfYouCan with grows "+howManyGrows+ " and font size "+fontSize+" return true");
          return true;
        }

      }else return false;
    }
  }
}


